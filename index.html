<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Draino â€” Word & Colours</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
        --tile-size: clamp(2.5rem, 15vmin, 5rem);
        --red-color: #ef4444;
        --blue-color: #3b82f6;
        --green-color: #22c55e;
        --bg-color: #111827;
        --text-color: #f9fafb;
        --modal-bg-color: #1f2937;
    }

    body { font-family: 'Inter', sans-serif; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; background-color: var(--bg-color); color: var(--text-color); transition: background-color .4s ease, color .4s ease; }
    .tile {
      transition: transform .12s ease, filter .12s ease, box-shadow .18s ease, background-color .4s ease, border-color .4s ease;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / .2), 0 2px 4px -2px rgb(0 0 0 / .2);
      font-size: calc(var(--tile-size) * .55);
      border-radius: 0.75rem;
      letter-spacing: .5px;
      width: var(--tile-size); height: var(--tile-size);
      border: 2px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tile.selected { transform: scale(1.08); filter: brightness(1.18); }

    .tile > span {
        width: 70%;
        height: 70%;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }

    .tile.bg-red-500 { background-color: var(--red-color); }
    .tile.bg-blue-500 { background-color: var(--blue-color); }
    .tile.bg-green-500 { background-color: var(--green-color); }

    .tank { width: 20px; height: calc(var(--tile-size) * 5 + 0.5rem * 4); background: linear-gradient(to top, #111, #333); border-radius: 12px; overflow: hidden; position: relative; box-shadow: inset 0 0 8px rgba(255,255,255,0.1), 0 0 8px rgba(0,0,0,0.5); transition: background-color .4s ease, border-color .4s ease; border: 2px solid transparent; }
    .tank-fill { position: absolute; bottom: 0; width: 100%; border-radius: 12px; transition: height 0.4s ease, filter 0.25s ease, background .4s ease; will-change: height, filter; }
    .tank-fill.red { background: linear-gradient(to top, var(--red-color), var(--red-color)); }
    .tank-fill.blue { background: linear-gradient(to top, var(--blue-color), var(--blue-color)); }
    .tank-fill.green { background: linear-gradient(to top, var(--green-color), var(--green-color)); }
    
    #word-display, #message { height: 2.5rem; display: flex; align-items: center; justify-content: center; }

    header h1 { font-size: clamp(1.8rem, 5vw, 2.25rem); }
    #score { font-size: clamp(1rem, 3vw, 1.25rem); }
    #word-display { font-size: clamp(1.2rem, 4vw, 1.75rem); }

    #startup-screen h2 { color: #e5e7eb; }
    .mode-btn { background-color: transparent; border: 1px solid #585072; color: #a7a0c4; }
    .mode-btn.selected { background-color: #6d28d9; border-color: #6d28d9; color: #ffffff; }
    #theme-select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3E%3C/svg%3E"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-right: 2.5rem; background-color: #1f2937; border: 1px solid #4b5563; color: white; }
    
    .neon-disco-theme .tile { background-color: transparent; text-shadow: 0 0 5px currentColor, 0 0 10px currentColor; }
    .neon-disco-theme .tile.bg-red-500 { border-color: var(--red-color); box-shadow: 0 0 8px var(--red-color), inset 0 0 5px var(--red-color); }
    .neon-disco-theme .tile.bg-blue-500 { border-color: var(--blue-color); box-shadow: 0 0 8px var(--blue-color), inset 0 0 5px var(--blue-color); }
    .neon-disco-theme .tile.bg-green-500 { border-color: var(--green-color); box-shadow: 0 0 8px var(--green-color), inset 0 0 5px var(--green-color); }
    
    .mrc-theme .tile { border-width: 1px; box-shadow: none; }
    .mrc-theme .tile.bg-red-500 { border-color: var(--red-color); background-color: rgba(147, 51, 234, 0.15); }
    .mrc-theme .tile.bg-blue-500 { border-color: var(--blue-color); background-color: rgba(59, 130, 246, 0.15); }
    .mrc-theme .tile.bg-green-500 { border-color: var(--green-color); background-color: rgba(236, 72, 153, 0.15); }
    .mrc-theme .tank { border-width: 1px; border-color: #6b7280; }

    @media (max-width: 767px) {
      #banks {
        flex-direction: column;
        width: 100%;
        max-width: calc(var(--tile-size) * 5 + 0.5rem * 4);
        gap: 0.5rem;
      }
      .tank {
        width: 100%;
        height: 20px;
      }
      .tank-fill {
        right: 0;
        top: 0;
        bottom: auto;
        height: 100%;
        transition: width 0.4s ease, filter 0.25s ease, background .4s ease;
        will-change: width, filter;
      }
    }
  </style>
</head>
<body class="p-4">

<div id="startup-screen" class="w-full max-w-lg mx-auto text-center p-6 bg-gray-900 rounded-2xl shadow-2xl border border-gray-700">
      <h1 class="text-5xl font-bold tracking-wider bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-pink-500 drop-shadow-lg mb-4">Draino</h1>
      <p class="text-lg mb-6">Select a mode and theme to begin.</p>
      
      <div class="mb-6">
          <h2 class="text-xl font-medium mb-4">Game Mode</h2>
          <div class="flex justify-center gap-4">
              <button data-mode="zen" class="mode-btn w-32 py-1.5 rounded-lg text-base font-medium transition-all">Peace Out</button>
              <button data-mode="regular" class="mode-btn w-32 py-1.5 rounded-lg text-base font-medium transition-all">Regular</button>
              <button data-mode="competition" class="mode-btn w-32 py-1.5 rounded-lg text-base font-medium transition-all">Competition</button>
          </div>
      </div>

      <div class="mb-8">
          <h2 class="text-xl font-medium mb-4">Theme</h2>
          <select id="theme-select" class="w-full max-w-xs mx-auto p-2 rounded-lg text-base">
              <option value="" disabled selected>Select a theme...</option>
          </select>
      </div>

      <button id="start-game-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-10 rounded-lg text-xl transition-transform transform hover:scale-105 disabled:bg-gray-700 disabled:text-gray-400 disabled:cursor-not-allowed disabled:scale-100" disabled>Start Game</button>
  </div>


  <div id="game-container" class="hidden w-full max-w-5xl mx-auto flex flex-col items-center gap-4">
    <header class="text-center">
      <h1 class="font-bold tracking-wider bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-pink-500 drop-shadow-lg">Draino</h1>
      <p id="subtitle" class="text-base mt-1">Find words to restore the coloured banks!</p>
      <p id="score" class="mt-2 font-bold">Score: 0</p>
    </header>
    <div class="w-full flex flex-col md:flex-row justify-center items-center md:items-end gap-4 md:gap-10">
        <!-- Left Column (Tanks) -->
        <div class="flex flex-col items-center w-full md:w-28 flex-shrink-0">
            <div id="speed-indicator-container" class="h-8 mb-2 text-center text-base font-bold tracking-widest hidden relative">
                <span id="speed-up-text" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-80 text-cyan-400 transition-opacity duration-300 opacity-0 rounded-md">SPEED UP!</span>
                <span id="speed-mph-display" class="text-yellow-400"></span>
            </div>
            <div id="banks" class="flex flex-row items-end justify-center gap-2">
              <div class="tank"><div id="red-bank" class="tank-fill red" style="height:100%"></div></div>
              <div class="tank"><div id="blue-bank" class="tank-fill blue" style="height:100%"></div></div>
              <div class="tank"><div id="green-bank" class="tank-fill green" style="height:100%"></div></div>
            </div>
        </div>

        <!-- Center Column (Grid) -->
        <div class="grid grid-cols-5 gap-2 justify-center" id="grid-container"></div>
        
        <!-- Right Column (Spacer) -->
        <div class="w-28 flex-shrink-0 hidden md:block"></div>
    </div>
    <div class="relative w-full mt-2" style="height: 2.5rem;">
        <p id="word-display" class="absolute inset-0 flex items-center justify-center font-bold tracking-widest text-gray-200 transition-opacity duration-200"></p>
        <p id="message" class="absolute inset-0 flex items-center justify-center text-base font-semibold opacity-0 transition-opacity duration-200"></p>
    </div>
  </div>

<div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center">
    <div class="bg-gray-800 rounded-2xl p-8 text-center shadow-2xl border border-gray-700">
      <h2 class="text-3xl font-bold text-red-500 mb-2">All Colours Drained!</h2>
      <p class="text-lg text-gray-300 mb-4">Game Over</p>
      <p id="final-score" class="text-xl text-yellow-400 font-bold mb-6">Final Score: 0</p>
      <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg text-base transition-transform transform hover:scale-105">Play Again</button>
    </div>
  </div>

  <script>
    // --- Game Configuration ---
    const GRID_SIZE = 5;
    const MIN_WORD_LENGTH = 3;
    const LONG_WORD_THRESHOLD = 4;
    const LONG_WORD_BONUS_MULTIPLIER = 1.5;
    const VOWELS = 'aaaaaaaeeeeeeeeeeeeiiiiiiiiooooooouuuu';
    const CONSONANTS = 'bbcccdddffgghhhkklllmmmnnnnnppprrrrrrssssstttttvvwwwyy';
    const COLORS = [
      { name: 'red', class: 'bg-red-500' }, { name: 'blue', class: 'bg-blue-500' }, { name: 'green', class: 'bg-green-500' }
    ];
    const INITIAL_BANK_LEVEL = 10;
    const MAX_BANK_LEVEL = 10;
    const BASE_DRAIN_RATE = 0.1;
    const BASE_DRAIN_INTERVAL_MS = 1000;
    const COMPETITION_SCORE_THRESHOLD = 100;
    const COMPETITION_SPEED_INCREASE = 150; // ms
    const MIN_DRAIN_INTERVAL = 250; //ms
    const MPH_LEVELS = [90, 110, 150, 200, 260, 330, 400, 500];

    // --- Game State ---
    let wordSet = new Set();
    const bannedWords = new Set(['arse', 'ass', 'asshole', 'bastard', 'bitch', 'bollocks', 'bugger', 'bullshit', 'choad', 'chode', 'cock', 'crap', 'cunt', 'damn', 'dick', 'fag', 'faggot', 'fuck', 'hell', 'jizz', 'knob', 'motherfucker', 'piss', 'prick', 'pussy', 'shit', 'slut', 'twat', 'wank', 'wanker', 'whore']);
    let grid = [];
    let currentSelection = [];
    let isSelecting = false;
    let colourBanks = {};
    let drainInterval;
    let currentDrainIntervalMs = BASE_DRAIN_INTERVAL_MS;
    let score = 0;
    let isGameOver = false;
    let gameMode = ''; // 'zen', 'regular', 'competition'
    let selectedTheme = '';
    let activeTouchId = null;
    let messageTimeout;
    let lastMessageColor = '';

    // --- Themes ---
    const THEMES = {
        'mrc': {
            name: 'Mr C\'s Choice',
            special: true,
            colors: { red: '#9333ea', blue: '#3b82f6', green: '#ec4899', bg: '#101727', text: '#e5e7eb' }
        },
        'regular': {
            name: 'Regular',
            colors: { red: '#ef4444', blue: '#3b82f6', green: '#22c55e', bg: '#101727', text: '#f9fafb' }
        },
        'autumn': { name: 'Autumn', colors: { red: '#d97706', blue: '#b91c1c', green: '#84cc16', bg: '#422006', text: '#fef3c7' } },
        'francais': {
            name: 'La Francais',
            colors: { red: '#dc2626', blue: '#2563eb', green: '#e5e7eb', bg: '#102a43', text: '#f3f4f6' },
            textColorOverride: { green: '#102a43' }
        },
        'neon-disco': {
            name: 'Neon Disco',
            special: true,
            colors: { red: '#f43f5e', blue: '#38bdf8', green: '#34d399', bg: '#1a1a2e', text: '#f0f0f0' }
        },
        'cosmic': {
            name: 'Melon Bliss',
            colors: { red: '#f472b6', blue: '#a78bfa', green: '#5eead4', bg: '#020617', text: '#e2e8f0' },
            textColorOverride: { green: '#020617' }
        },
        'candyland': {
            name: 'Candyland',
            colors: { red: '#f472b6', blue: '#60a5fa', green: '#fde047', bg: '#5b21b6', text: '#fee2e2' },
            textColorOverride: { green: '#831843' }
        },
        'jungle': { name: 'Tropical Jungle', colors: { red: '#f43f5e', blue: '#0ea5e9', green: '#16a34a', bg: '#052e22', text: '#a7f3d0' } },
        'monochrome': {
            name: 'Monochrome',
            colors: { red: '#f9fafb', blue: '#4b5563', green: '#9ca3af', bg: '#111827', text: '#f9fafb'},
            textColorOverride: { red: '#111827', green: '#111827' }
        }
    };

    // --- DOM Elements ---
    const startupScreen = document.getElementById('startup-screen');
    const gameContainer = document.getElementById('game-container');
    const gridContainer = document.getElementById('grid-container');
    const wordDisplay = document.getElementById('word-display');
    const messageEl = document.getElementById('message');
    const scoreEl = document.getElementById('score');
    const gameOverModal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    const startGameBtn = document.getElementById('start-game-btn');
    const themeSelect = document.getElementById('theme-select');
    const modeButtons = document.querySelectorAll('.mode-btn');
    const speedIndicatorContainer = document.getElementById('speed-indicator-container');
    const speedUpText = document.getElementById('speed-up-text');
    const speedMphDisplay = document.getElementById('speed-mph-display');

    // --- Initialization ---
    function initializeApp() {
        setupStartupScreen();
        fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt')
            .then(r => r.ok ? r.text() : Promise.reject('Failed to load word list'))
            .then(data => {
                data.split('\n').forEach(w => w && wordSet.add(w.trim().toLowerCase()));
            }).catch(error => {
                console.error("Error fetching word list:", error);
                startupScreen.innerHTML = `<p class="text-red-500">Could not load game dictionary. Please refresh the page.</p>`;
            });
    }

    function setupStartupScreen() {
        Object.entries(THEMES).forEach(([key, theme]) => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = theme.name;
            themeSelect.appendChild(option);
        });
        modeButtons.forEach(btn => btn.addEventListener('click', () => {
            gameMode = btn.dataset.mode;
            modeButtons.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            validateSelections();
        }));
        themeSelect.addEventListener('change', e => {
            selectedTheme = e.target.value;
            validateSelections();
        });
        startGameBtn.addEventListener('click', () => {
            startupScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            applyTheme(selectedTheme);
            startGame();
        });
    }
    
    function validateSelections() {
        if (gameMode && selectedTheme) {
            startGameBtn.disabled = false;
        }
    }
    
    function applyTheme(themeKey) {
        const theme = THEMES[themeKey];
        const root = document.documentElement;
        
        root.style.setProperty('--red-color', theme.colors.red);
        root.style.setProperty('--blue-color', theme.colors.blue);
        root.style.setProperty('--green-color', theme.colors.green);
        root.style.setProperty('--bg-color', theme.colors.bg);
        root.style.setProperty('--text-color', theme.colors.text);

        document.body.classList.remove('neon-disco-theme', 'mrc-theme');
        if (theme.special) {
             if(themeKey === 'neon-disco') document.body.classList.add('neon-disco-theme');
             if(themeKey === 'mrc') document.body.classList.add('mrc-theme');
        }
    }

    // --- Game Logic ---
    function startGame() {
        isGameOver = false;
        score = 0;
        colourBanks = { red: INITIAL_BANK_LEVEL, blue: INITIAL_BANK_LEVEL, green: INITIAL_BANK_LEVEL };
        currentDrainIntervalMs = BASE_DRAIN_INTERVAL_MS;
        gameOverModal.classList.add('hidden');
        
        if (gameMode === 'competition') {
            speedIndicatorContainer.classList.remove('hidden');
            updateSpeedDisplay();
        } else {
            speedIndicatorContainer.classList.add('hidden');
        }

        generateGrid();
        renderBanks();
        if (gameMode !== 'zen') {
            startDrain();
        }
    }
    
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

    function generateLetters(){
      const totalTiles = GRID_SIZE * GRID_SIZE;
      const vowelCount = 9 + Math.floor(Math.random() * 2); // Guarantees 9 or 10 vowels
      const consonantCount = totalTiles - vowelCount;
      const letters = [];
      for(let i=0;i<vowelCount;i++) letters.push(VOWELS[Math.floor(Math.random()*VOWELS.length)]);
      for(let i=0;i<consonantCount;i++) letters.push(CONSONANTS[Math.floor(Math.random()*CONSONANTS.length)]);
      return shuffle(letters);
    }
    
    function generateGrid() {
        const letters = generateLetters();
        const colorDist = [...new Array(8).fill(COLORS[0]), ...new Array(8).fill(COLORS[1]), ...new Array(9).fill(COLORS[2])];
        const colours = shuffle(colorDist);
        grid = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            grid.push({ id: `tile-${i}`, letter: letters[i], colorName: colours[i].name });
        }

        gridContainer.innerHTML = '';
        grid.forEach((tile, i) => {
            const el = document.createElement('div');
            el.id = tile.id;
            el.dataset.index = String(i);
            el.className = `tile ${COLORS.find(c => c.name === tile.colorName).class}`;
            
            const letterSpan = document.createElement('span');
            letterSpan.textContent = tile.letter.toUpperCase();
            el.appendChild(letterSpan);

            const currentTheme = THEMES[selectedTheme];
            if (currentTheme.textColorOverride && currentTheme.textColorOverride[tile.colorName]) {
                letterSpan.style.color = currentTheme.textColorOverride[tile.colorName];
            }
            gridContainer.appendChild(el);
        });
    }
    
    function drainBanks(){
      if (isGameOver) return;
      COLORS.forEach(c => { colourBanks[c.name] = Math.max(0, colourBanks[c.name] - BASE_DRAIN_RATE); });
      renderBanks();
      if (Object.values(colourBanks).every(v => v <= 0)) {
        endGame();
      }
    }

    function endGame() {
        isGameOver = true;
        clearInterval(drainInterval);
        finalScoreEl.textContent = `Final Score: ${score}`;
        gameOverModal.classList.remove('hidden');
    }

    function startDrain(){ clearInterval(drainInterval); drainInterval = setInterval(drainBanks, currentDrainIntervalMs); }

    function checkCompetitionSpeedUp(oldScore, newScore) {
        if (gameMode !== 'competition') return;
        const oldThreshold = Math.floor(oldScore / COMPETITION_SCORE_THRESHOLD);
        const newThreshold = Math.floor(newScore / COMPETITION_SCORE_THRESHOLD);
        if (newThreshold > oldThreshold) {
            const newInterval = Math.max(MIN_DRAIN_INTERVAL, BASE_DRAIN_INTERVAL_MS - (newThreshold * COMPETITION_SPEED_INCREASE));
            if (newInterval < currentDrainIntervalMs) {
                currentDrainIntervalMs = newInterval;
                
                speedUpText.classList.remove('opacity-0');
                
                setTimeout(() => {
                    speedUpText.classList.add('opacity-0');
                    updateSpeedDisplay();
                }, 1500);

                startDrain();
            }
        }
    }

    // --- Tile Selection Logic ---
    function areAdjacent(idx1, idx2) {
        const r1 = Math.floor(idx1 / GRID_SIZE), c1 = idx1 % GRID_SIZE;
        const r2 = Math.floor(idx2 / GRID_SIZE), c2 = idx2 % GRID_SIZE;
        return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
    }

    function handleSelectionStart(e) { 
        e.preventDefault();
        if (isGameOver) return;

        let targetElement;
        if (e.type === 'mousedown') {
            targetElement = e.target;
        } else if (e.type === 'touchstart') {
            if (activeTouchId !== null) return;
            const touch = e.changedTouches[0];
            activeTouchId = touch.identifier;
            targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        }

        if (targetElement && targetElement.closest('.tile')) {
            isSelecting = true; 
            resetSelection(); 
            selectTile(targetElement); 
        }
    }

    function handleSelectionMove(e) {
        e.preventDefault();
        if (!isSelecting || isGameOver) return;

        let targetElement;
        if (e.type === 'mouseover' || e.type === 'mousemove') {
            targetElement = e.target;
        } else if (e.type === 'touchmove') {
            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
            if (!touch) return;
            targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        }

        if (!targetElement) return;

        const tileContainer = targetElement.closest('.tile');
        const lastSelected = currentSelection.length > 0 ? currentSelection[currentSelection.length - 1] : null;

        if (tileContainer && lastSelected && !currentSelection.includes(tileContainer) && areAdjacent(Number(lastSelected.dataset.index), Number(tileContainer.dataset.index))) {
            selectTile(targetElement);
        }
    }

    function handleSelectionEnd(e) {
        let isOurTouch = false;
        if(e.type === 'mouseup') {
            isOurTouch = true;
        } else if (e.type === 'touchend' || e.type === 'touchcancel') {
            if(Array.from(e.changedTouches).some(t => t.identifier === activeTouchId)){
                 isOurTouch = true;
                 activeTouchId = null;
            }
        }
        
        if (isSelecting && isOurTouch) {
            isSelecting = false;
            if (currentSelection.length >= MIN_WORD_LENGTH) validateWord();
            else resetSelection();
        }
    }

    function selectTile(el) {
        const tileContainer = el.closest('.tile');
        if (!tileContainer || currentSelection.includes(tileContainer)) return;
        tileContainer.classList.add('selected');
        currentSelection.push(tileContainer);
        wordDisplay.textContent = currentSelection.map(t => t.querySelector('span').textContent).join('');
    }

    function resetSelection() {
        currentSelection.forEach(t => t.classList.remove('selected'));
        currentSelection = [];
        wordDisplay.textContent = '';
    }

    // --- Word Validation & Scoring ---
    function validateWord() {
        const word = currentSelection.map(t => t.querySelector('span').textContent.toLowerCase()).join('');
        if (word.length < MIN_WORD_LENGTH) {
            showMessage('Word too short!', 'text-yellow-400');
            resetSelection();
            return;
        }
        if (bannedWords.has(word)) {
            showMessage('Word not allowed!', 'text-red-400');
            resetSelection();
            return;
        }

        if (wordSet.has(word)) {
            const colorCounts = { red: 0, blue: 0, green: 0 };
            currentSelection.forEach(el => colorCounts[grid[Number(el.dataset.index)].colorName]++);
            for (const color in colorCounts) {
                colourBanks[color] = Math.min(MAX_BANK_LEVEL, colourBanks[color] + colorCounts[color]);
            }

            const isLongWord = word.length >= LONG_WORD_THRESHOLD;
            const points = isLongWord ? Math.floor(currentSelection.length * LONG_WORD_BONUS_MULTIPLIER) : currentSelection.length;
            const oldScore = score;
            score += points;
            checkCompetitionSpeedUp(oldScore, score);

            let successMsg = `+${points} pts!`;
            if (isLongWord) successMsg += ' (Bonus!)';
            showMessage(successMsg, 'text-green-400');
            replaceUsedTiles();
        } else {
            showMessage('Not a valid word!', 'text-red-400');
        }
        resetSelection();
        renderBanks();
    }

    function replaceUsedTiles() {
        const lettersPool = shuffle(generateLetters());
        const usedColorNames = currentSelection.map(el => grid[Number(el.dataset.index)].colorName);
        let letterIndex = 0;
        
        currentSelection.forEach(el => {
            const idx = Number(el.dataset.index);
            const newLetter = lettersPool[letterIndex++ % lettersPool.length];

            grid[idx].letter = newLetter;
            const letterSpan = el.querySelector('span');
            if (letterSpan) {
                letterSpan.textContent = grid[idx].letter.toUpperCase();
            }
            
            const newColorName = usedColorNames[Math.floor(Math.random() * usedColorNames.length)];
            grid[idx].colorName = newColorName;
            
            let oldColorClass = '';
            for(const c of COLORS) {
                if (el.classList.contains(c.class)) {
                    oldColorClass = c.class;
                    break;
                }
            }
            if (oldColorClass) el.classList.remove(oldColorClass);

            const newColor = COLORS.find(c => c.name === newColorName);
            el.classList.add(newColor.class);
            
            const currentTheme = THEMES[selectedTheme];
            if (letterSpan && currentTheme.textColorOverride && currentTheme.textColorOverride[newColorName]) {
                letterSpan.style.color = currentTheme.textColorOverride[newColorName];
            } else if (letterSpan) {
                letterSpan.style.color = '';
            }
        });
        balanceColors();
        balanceVowels();
    }
    
    // --- UI & Rendering ---
    function updateSpeedDisplay() {
        if (gameMode !== 'competition') return;
        const level = Math.floor(score / COMPETITION_SCORE_THRESHOLD);
        const mph = MPH_LEVELS[Math.min(level, MPH_LEVELS.length - 1)];
        speedMphDisplay.textContent = `${mph} MPH`;
    }

    function isVowel(letter) {
        return 'aeiou'.includes(letter.toLowerCase());
    }

    function balanceVowels() {
        const MIN_VOWELS = 9;
        const MAX_VOWELS = 10;
        let currentVowels = grid.filter(tile => isVowel(tile.letter)).length;

        const allIndices = Array.from({length: grid.length}, (_, i) => i);
        
        // Add vowels if count is too low
        while (currentVowels < MIN_VOWELS) {
            const consonantIndices = allIndices.filter(i => !isVowel(grid[i].letter));
            if (consonantIndices.length === 0) break; 

            const indexToChange = consonantIndices[Math.floor(Math.random() * consonantIndices.length)];
            grid[indexToChange].letter = VOWELS[Math.floor(Math.random() * VOWELS.length)];
            
            const el = document.getElementById(grid[indexToChange].id);
            el.querySelector('span').textContent = grid[indexToChange].letter.toUpperCase();
            currentVowels++;
        }

        // Remove vowels if count is too high
        while (currentVowels > MAX_VOWELS) {
            const vowelIndices = allIndices.filter(i => isVowel(grid[i].letter));
            if (vowelIndices.length === 0) break;

            const indexToChange = vowelIndices[Math.floor(Math.random() * vowelIndices.length)];
            grid[indexToChange].letter = CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];

            const el = document.getElementById(grid[indexToChange].id);
            el.querySelector('span').textContent = grid[indexToChange].letter.toUpperCase();
            currentVowels--;
        }
    }

    function balanceColors() {
        const counts = { red: 0, blue: 0, green: 0 };
        grid.forEach(tile => counts[tile.colorName]++);
        const minCount = 8;

        for (const color of COLORS) {
            while (counts[color.name] < minCount) {
                const donorColor = COLORS.find(c => counts[c.name] > minCount);
                if (!donorColor) {
                    break;
                };

                const donorIndex = grid.findIndex(t => t.colorName === donorColor.name);
                if (donorIndex === -1) break;

                grid[donorIndex].colorName = color.name;
                const el = document.getElementById(grid[donorIndex].id);
                
                const oldColorClass = COLORS.find(c => c.name === donorColor.name).class;
                const newColorClass = COLORS.find(c => c.name === color.name).class;
                el.classList.remove(oldColorClass);
                el.classList.add(newColorClass);

                const letterSpan = el.querySelector('span');
                const currentTheme = THEMES[selectedTheme];
                if (letterSpan && currentTheme.textColorOverride) {
                    if (currentTheme.textColorOverride[color.name]) {
                        letterSpan.style.color = currentTheme.textColorOverride[color.name];
                    } else {
                        letterSpan.style.color = '';
                    }
                }

                counts[color.name]++;
                counts[donorColor.name]--;
            }
        }
    }
    function renderBanks(){
      const isMobile = window.innerWidth < 768;
      for(const c of COLORS){
        const fill = document.getElementById(`${c.name}-bank`);
        if (fill) {
            const percentage = (colourBanks[c.name] / MAX_BANK_LEVEL) * 100;
            
            fill.style.width = '';
            fill.style.height = '';

            if (isMobile) {
              fill.style.width = `${percentage}%`;
            } else {
              fill.style.height = `${percentage}%`;
            }

            fill.style.filter = `brightness(${0.7 + colourBanks[c.name] / MAX_BANK_LEVEL * 0.3})`;
        }
      }
      scoreEl.textContent = `Score: ${score}`;
    }

    function showMessage(msg, cls){
      clearTimeout(messageTimeout);

      // Remove the previous color class if it exists
      if (lastMessageColor) {
        messageEl.classList.remove(lastMessageColor);
      }
      
      // Add the new color class and store it
      messageEl.classList.add(cls);
      lastMessageColor = cls;
      
      messageEl.textContent = msg;
      
      wordDisplay.classList.add('opacity-0');
      messageEl.classList.remove('opacity-0');
      
      messageTimeout = setTimeout(() => { 
        messageEl.classList.add('opacity-0');
        wordDisplay.classList.remove('opacity-0');
      }, 2000);
    }
    
    // --- Event Listeners (Robust Version) ---
    gridContainer.addEventListener('mousedown', handleSelectionStart);
    window.addEventListener('mousemove', handleSelectionMove);
    window.addEventListener('mouseup', handleSelectionEnd);

    gridContainer.addEventListener('touchstart', handleSelectionStart, { passive: false });
    window.addEventListener('touchmove', handleSelectionMove, { passive: false });
    window.addEventListener('touchend', handleSelectionEnd);
    window.addEventListener('touchcancel', handleSelectionEnd);
    window.addEventListener('resize', renderBanks);
    
    restartButton.addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        startupScreen.classList.remove('hidden');
        gameContainer.classList.add('hidden');
        
        speedIndicatorContainer.classList.add('hidden');

        const root = document.documentElement;
        root.style.setProperty('--bg-color', '#111827');
        root.style.setProperty('--text-color', '#f9fafb');
        themeSelect.value = "";
        gameMode = "";
        selectedTheme = "";
        modeButtons.forEach(b => b.classList.remove('selected'));
        validateSelections();
    });

    // --- Start the app ---
    document.addEventListener('DOMContentLoaded', initializeApp);

  </script>
</body>
</html>








